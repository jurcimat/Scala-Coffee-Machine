<h2>Modifying collections</h2>
<p>We can define a new <code class="language-scala">List</code>, <code class="language-scala">Set</code>, or <code class="language-scala">Map</code>, or, alternatively, change an existing one by adding or removing elements, like a football coach would manage the team players by adding or removing candidates for the match. For the sake of efficacy, we can perform other modifications, as well: substitute one player with another or filter players by strength.</p>

<p>In this topic, we will discuss the type of operations that can help us modify collections in Scala.</p>

<h5 id="copying-with-updates">Copying with updates</h5>

<p>In Scala, collections are typically immutable. So, to introduce any modifications, we should start with learning how to copy collections:</p>

<pre><code class="language-scala">scala&gt; val list = List(1, 2, 3)
list: List[Int] = List(1, 2, 3)
scala&gt; list.updated(1, 5)
res1: List[Int] = List(1, 5, 3)</code></pre>

<p>With the help of <code class="language-scala">updated</code>, we copied all the elements except the one specified by index and a new value for it. Note that we can't use <code class="language-scala">updated</code> with <code class="language-scala">Set</code> because it doesn't work with a defined index:</p>

<pre><code class="language-scala">scala&gt; val set = Set('a', 'b', 'c')
set: scala.collection.immutable.Set[Char] = Set(a, b, c)
scala&gt; set.updated(1, 'c')
&lt;console&gt;:13: error: value updated is not a member of scala.collection.immutable.Set[Char]
       set.updated(1, 'c')</code></pre>

<p><code class="language-scala">Map</code> allows for probably the most interesting updates. This follows from the nature of this data structure: if you match some value with a key, you will probably change the value at some point. You can do that easily with <code class="language-scala">updated</code> or <code class="language-scala">+</code>:</p>

<pre><code class="language-scala">scala&gt; val map = Map('a' -&gt; 1, 'b' -&gt; 2)
map: scala.collection.immutable.Map[Char,Int] = Map(a -&gt; 1, b -&gt; 2)
scala&gt; map.updated('a', 0)
res1: scala.collection.immutable.Map[Char,Int] = Map(a -&gt; 0, b -&gt; 2)
scala&gt; map + ('a' -&gt; 1)
res2: scala.collection.immutable.Map[Char,Int] = Map(a -&gt; 1, b -&gt; 2)
scala&gt; map + ('c' -&gt; 3)
res3: scala.collection.immutable.Map[Char,Int] = Map(a -&gt; 1, b -&gt; 2, c -&gt; 3)</code></pre>

<p>Note that with <code class="language-scala">updated</code> in Maps, we use two arguments: the key and the new value, while with <code class="language-scala">+</code>, we just add a new pair as a single parameter. You can update and add new pairs with a single <code class="language-scala">+</code> operation. </p>

<h5 id="filtering">Filtering</h5>

<p>Scala has an interesting technique to transform one collection into another with the help of transforming methods. Imagine that you have a list of numbers and you want to get only the even numbers from it. For this purpose, you can use <code class="language-scala">filter</code>:</p>

<pre><code class="language-scala">scala&gt; val list = List(1, 2, 3, 4)
list: List[Int] = List(1, 2, 3, 4)
scala&gt; def even: Int =&gt; Boolean = e =&gt; e % 2 == 0
even: Int =&gt; Boolean
scala&gt; list.filter(even)
res1: List[Int] = List(2, 4)
</code></pre>

<p>Above, we iterated over the elements of the list and filtered only the even ones. To do that, we predefined a helper function <code class="language-scala">even</code> and passed it as a parameter. That function transformed the element to a <code class="language-scala">Boolean</code> value and if the result is <code class="language-scala">true</code>, it includes the element in the new collection. The same functionality could be applied to <code class="language-scala">Set</code> or <code class="language-scala">Map</code>:</p>

<pre><code class="language-scala">scala&gt; val set = Set(1, 2, 3)
set: scala.collection.immutable.Set[Int] = Set(1, 2, 3)
scala&gt; def moreOne(i: Int) = i &gt; 1
moreOne: (i: Int)Boolean
scala&gt; set.filter(moreOne)
res1: scala.collection.immutable.Set[Int] = Set(2, 3)
scala&gt; def isTupleAOne(tuple: (Char, Int)) = tuple._1 == 'a' &amp;&amp; tuple._2 == 1
isTupleAOne: (tuple: (Char, Int))Boolean
scala&gt; val map = Map('a' -&gt; 0)
map: scala.collection.immutable.Map[Char,Int] = Map(a -&gt; 0)
scala&gt; map.filter(isTupleAOne)
res2: scala.collection.immutable.Map[Char,Int] = Map()</code></pre>

<p>In the snippet above, we wanted to include in the new collection only the elements that can pass the <code class="language-scala">filter</code>. For <code class="language-scala">Set</code>, we specified a helper function to get only the numbers larger than one, and for <code class="language-scala">Map</code>, we want only the pairs (as elements are tuples) with 'a' as the first and "1" as the second. </p>

<h5 id="mapping">Mapping</h5>

<p>With filters, we can use a helper function to transform the element to <code class="language-scala">Boolean</code>. We can go further and ask: is it possible to define a helper function to transform an element to any other value and use it to make a new collection? This is exactly what the <code class="language-scala">map</code> operation does: we pass the function from one element to another and create a new collection with this technique:</p>

<pre><code class="language-scala">scala&gt; val list = List(1, 2, 3)
list: List[Int] = List(1, 2, 3)
scala&gt; def plusOne(i: Int): Int = i + 1
plusOne: (i: Int)Int
scala&gt; list.map(plusOne)
res1: List[Int] = List(2, 3, 4)</code></pre>

<p>Above, we defined a function <code class="language-scala">plusOne</code> to increment the element value of the new collection. We can do the same for <code class="language-scala">Set</code>:</p>

<pre><code class="language-scala">scala&gt; val set = Set(1, 2, 3)
set: scala.collection.immutable.Set[Int] = Set(1, 2, 3)
scala&gt; set.map(e =&gt; "elem" + e)
res1: scala.collection.immutable.Set[String] = Set(elem1, elem2, elem3)
</code></pre>

<p>Note that above, we used the inline form of the definition for the function, which is convenient if you need a helper only for one operation. In addition, the function transforms <code class="language-scala">Int</code> to <code class="language-scala">String</code>, so <code class="language-scala">map</code> gives you the ability to change the types of the collection's elements.</p>

<p>We can transform a <code class="language-scala">Map</code> as well:</p>

<pre><code class="language-scala">scala&gt; val map = Map('a' -&gt; 1, 'b' -&gt; 2)
map: scala.collection.immutable.Map[Char,Int] = Map(a -&gt; 1, b -&gt; 2)
scala&gt; def cKey(pair: (Char, Int)) = 'c' -&gt; pair._2
cKey: (pair: (Char, Int))(Int, Int)
scala&gt; map.map(cKey)
res1: scala.collection.immutable.Map[Int,Int] = Map('c' -&gt; 2)</code></pre>

<p>Note that here, we mapped all the keys of <code class="language-scala">Map</code> to one value <code class="language-scala">'c'</code>, and the result contains only one pair as it is impossible to have several values with one key in this collection type.</p>

<h5 id="var-and-collections">Var and collections</h5>

<p>It looks like we always have to make a new collection, but what if we want to change an existing one? For example, say we have a set of cinema tickets in our application, and these tickets are sold to users. If we generate a new collection without a ticket that has been sold, the original one still contains it and somebody could buy it again. To avoid this, you can init a collection as <code class="language-scala">var</code> and make changes in place:</p>

<pre><code class="language-scala">scala&gt; var tickets = Set("A1", "B4")
tickets: scala.collection.immutable.Set[String] = Set(A1, B4)
scala&gt; tickets = tickets - "A1"
tickets: scala.collection.immutable.Set[String] = Set(B4)
scala&gt; tickets = tickets - "B4"
tickets: scala.collection.immutable.Set[String] = Set()</code></pre>

<p>We assigned the <code class="language-scala">tickets</code> variable to a new collection without the element that has been sold. We can use the same approach for saving variables we want to use in the future:</p>

<pre><code class="language-scala">scala&gt; var variables: Map[String,Int] = Map.empty
variables: Map[String,Int] = Map()
scala&gt; variables += "n" -&gt; 5 
scala&gt; variables
res1: Map[String,Int] = Map(n -&gt; 5)
scala&gt; variables("n")
res2: Int = 5
</code></pre>

<p>Note that we can use the operation <code class="language-scala">+=</code> as a shortcut for <code class="language-scala">a = a +</code>.</p>

<h5 id="conclusion">Conclusion</h5>

<p>Modification of collections gives you the ability to transform predefined ones in different ways. For example, <code class="language-scala">updated</code> substitutes an element with another one while copying others. Filtering passes only the elements that return true with a helper function to generate a collection. Mapping will use a helper function to transform elements to any other value and put them in a new collection. Finally, we can create a new collection as a 'variable' to make changes in place.</p>
