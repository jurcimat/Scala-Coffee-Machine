<h2>Defining new collections</h2>
<p>You are already familiar with the main collection types in Scala: <code class="language-scala">List</code>, <code class="language-scala">Set</code> and <code class="language-scala">Map</code>. These collections of elements can be defined as sequences of elements or pairs. In this topic, we will look deeper into defining collections: specifically, we will discuss how to use parts of previously defined collections to construct a new one.</p>

<h5 id="empty-collections">Empty collections</h5>

<p>Let's start by considering those collections that have no elements.</p>

<p>There is a special symbol for defining an empty list in Scala: <code class="language-scala">Nil</code>, which accomplishes the same as <code class="language-scala">List()</code> or <code class="language-scala">List.empty</code>. For <code class="language-scala">Set</code> and <code class="language-scala">Map</code> we don't really have anything similar to <code class="language-scala">Nil</code>, but <code class="language-scala">.empty</code> works just fine.</p>

<p>Let's look at a few examples:</p>

<pre><code class="language-scala">scala&gt; val list: List[Int] = Nil
list: List[Int] = List()
scala&gt; val list2 = List.empty[Int]
list2: List[Int] = List()
scala&gt; val set = Set.empty[Char]
set: scala.collection.immutable.Set[Char] = Set()
scala&gt; val map = Map.empty[Char, Int]
map: scala.collection.immutable.Map[Char,Int] = Map()</code></pre>

<p>A big advantage of using <code class="language-scala">.empty[]</code> is that you can specify the type of elements when you're constructing a collection.</p>

<h5 id="copying">Copying </h5>

<p>In Scala, we typically treat an existing collection as <strong>immutable</strong>: that is, we can't change any elements in place. What you can do instead is generate a new collection with copies of elements that we need, just like this:</p>

<pre><code class="language-scala">scala&gt; val list = List(1, 2, 3)
list: List[Int] = List(1, 2, 3)
scala&gt; val list2 = list.tail
list2: List[Int] = List(2, 3)</code></pre>

<p>Here, we generated <code class="language-scala">list2</code> from the original one by omitting the first element and keeping the rest. We can add new elements to collections the same way:</p>

<pre><code class="language-scala">scala&gt; 0 :: list
res1: List[Int] = List(0, 1, 2, 3)
scala&gt; list :+ 4
res2: List[Int] = List(1, 2, 3, 4)
</code></pre>

<p>A list can be copied to create a new list with various types of modifications. Let's consider some of them:</p>

<pre><code class="language-scala">scala&gt; list.drop(1)
res1: List[Int] = List(2, 3)
scala&gt; list.take(1)
res2: List[Int] = List(1)
scala&gt; list.reverse
res3: List[Int] = List(3, 2, 1)</code></pre>

<p>Above, we used <code class="language-scala">drop</code> to get rid of the first element, <code class="language-scala">take</code> to get only the specified elements, and <code class="language-scala">reverse</code> to get the elements in the opposite order. </p>

<p>We can add a new element to a <code class="language-scala">Set</code> as well; note that adding an existing element doesn't change anything in the new collection generated:</p>

<pre><code class="language-scala">scala&gt; val set = Set('a', 'b')
set: scala.collection.immutable.Set[Char] = Set(a, b)
scala&gt; val set2 = set + 'c'
set2: scala.collection.immutable.Set[Char] = Set(a, b, c)
scala&gt; set - 'a'
res1: scala.collection.immutable.Set[Char] = Set(b)
scala&gt; set + 'a'
res2: scala.collection.immutable.Set[Char] = Set(a, b)</code></pre>

<p>It is also possible to use copying for a <code class="language-scala">Map</code>:</p>

<pre><code class="language-scala">scala&gt; val map = Map(1 -&gt; 'a', 2 -&gt; 'b', 5 -&gt; 'a')
map: scala.collection.immutable.Map[Int,Char] = Map(1 -&gt; a, 2 -&gt; b, 5 -&gt; a)
scala&gt; val map2 = map.drop(1)
map2: scala.collection.immutable.Map[Int,Char] = Map(2 -&gt; b, 5 -&gt; a)
scala&gt; val map3 = map + (6 -&gt; 'c')
map3: scala.collection.immutable.Map[Int,Char] = Map(1 -&gt; a, 2 -&gt; b, 5 -&gt; a, 6 -&gt; c)</code></pre>

<p>Note that <code class="language-scala">map2</code> contains a subset of elements from <code class="language-scala">map</code> but they are the same old elements, not new. For <code class="language-scala">map3</code>, we added a new element but others are from <code class="language-scala">map</code>. As our collections are <strong>immutable</strong> we can't change elements themselves but we can easily reuse them.</p>

<h5 id="concatenation">Concatenation</h5>

<p>You can create new collections not only by adding or removing elements but also by joining two collections of the same type. This is called <strong>concatenation</strong>.</p>

<p>For <code class="language-scala">List</code>, <code class="language-scala">Set</code>, and <code class="language-scala">Map</code>, use the <code class="language-scala">++</code> operation:</p>

<pre><code class="language-scala">scala&gt; List(1, 2) ++ List(2, 3)
res1: List[Int] = List(1, 2, 2, 3)
scala&gt; List(1, 2) ++ List.empty[Int]
res2: List[Int] = List(1, 2)
scala&gt; List(1, 2) ++ Set(1)
res3: List[Int] = List(1, 2, 1)</code></pre>

<p>If we combine a <code class="language-scala">List</code> with a <code class="language-scala">Set</code>, the result will have whatever type we used first. Remember that in <code class="language-scala">Set</code>, we cannot have duplicate elements:</p>

<pre><code class="language-scala">scala&gt; Set(1, 2) ++ Set(2, 3)
res1: scala.collection.immutable.Set[Int] = Set(1, 2, 3)
scala&gt; Set.empty[Int] ++ Set(2, 3)
res2: scala.collection.immutable.Set[Int] = Set(2, 3)
scala&gt; Set(2, 3) ++ List(3)
res3: scala.collection.immutable.Set[Int] = Set(2, 3)
</code></pre>

<p>For <code class="language-scala">Map</code>, we can use concatenation, as well:</p>

<pre><code class="language-scala">scala&gt; Map('a' -&gt; 1) ++ Map('b' -&gt; 2)
res1: scala.collection.immutable.Map[Char,Int] = Map(a -&gt; 1, b -&gt; 2)
scala&gt; Map('a' -&gt; 1, 'b' -&gt; 2) ++ Map('a' -&gt; 0, 'c' -&gt; 3)
res2: scala.collection.immutable.Map[Char,Int] = Map(a -&gt; 0, b -&gt; 2, c -&gt; 3)
</code></pre>

<p>Notice that in the case of key duplicates in <code class="language-scala">Map</code>, we substitute the values with the last variant we have.</p>

<h5 id="conclusion">Conclusion</h5>

<p>Defining an empty collection gives us the ability to construct a <code class="language-scala">List</code>, a <code class="language-scala">Set</code>, or a <code class="language-scala">Map</code> without any elements. You can't change the immutable types, but what you can do is copy an existing collection and add, remove, or update individual elements. With concatenation, you can combine two or more collections to produce new one.</p>
