<h2>Branching</h2>
<p>Imagine that you want to write a function to get the absolute value: if integer argument <code class="language-scala">x</code> is negative, return <code class="language-scala">-x</code>, and otherwise, return the <code class="language-scala">x</code> itself. By definition, you will need something to separate the ways to get the result. The realization of such an approach in programming is called conditional execution, fork, or <strong>branching</strong>. Scala has the <code class="language-scala">if else</code> syntax for this process.</p>

<h5 id="if-else">If-else</h5>

<p>The construction is quite intuitive: in a way, it resembles the way we speak when we set conditions. Take a look at this example:</p>

<pre><code class="language-scala">scala&gt; val a = -5
a: Int = -5
scala&gt; if (a &gt;= 0) print(a) else print(-a) 
5
</code></pre>

<p>Here, we act conditionally on the value of <code class="language-scala">a</code>, and the condition has to be an expression with the <code class="language-scala">Boolean</code> result. The construction has two branches: if the condition is <em>true, </em>the part following the condition (<strong>then-part</strong>) is executed, and if otherwise, it's the part following else (<strong>else-part</strong>). </p>

<p>Note that <code class="language-scala">if else</code> is an expression, so it is evaluated and returns the result:</p>

<pre><code class="language-scala">scala&gt; val a = -5
a: Int = -5
scala&gt; if (a == -5) -1 else 1
res1: Int = -1
</code></pre>

<p>The expression has to be consistent, so both <em>then</em> and <em>else</em> parts have to return the same type. If we don't follow this rule, we may receive results automatically resolved by the Scala compiler, so the result of the expression could be different from your expectations.</p>

<pre><code class="language-scala">scala&gt; if (a == -5) -1 else 1.0
res2: Double = -1.0
</code></pre>

<p>In the example above, we return <code class="language-scala">Int</code> or <code class="language-scala">Double</code>, and the compiler selects numeric with a wider area of values, which is <code class="language-scala">Double</code>.</p>

<p>You can omit the else-part, which returns <em>Unit</em>:</p>

<pre><code class="language-scala">scala&gt; if (a == -5) print(-a)
5
scala&gt; if (a == -5) print(-a) else ()
5
</code></pre>

<h5 id="if-else-if">If-else-if</h5>

<p>Sometimes the world is more complicated than left-right or black-white. So what do you do if your Scala program has more than two paths? For sure, you can make several <code class="language-scala">if else</code>  constructions using nesting:</p>

<pre><code class="language-scala">scala&gt; val a = -5
a: Int = -5
scala&gt; if (a &lt; 0) print("negative") else
     | if (a % 2 == 0) print("even") else print("odd") 
negative
</code></pre>

<p>Above, we added another branching to the else-part of expression. We can do the same for the then-part:</p>

<pre><code class="language-scala">scala&gt; if (a &lt; 0)
     | if (a % 2 == 0) print("even") else print("odd") else 
     | print("positive")
odd</code></pre>

<p>Of course, you can add nesting in both parts without any limits on the nesting depth. Looks a little messy? Scala has additional syntax with <code class="language-scala">else-if</code> to make such expressions more readable:</p>

<pre><code class="language-scala">scala&gt; if (a &lt; 0) {
     |   println("negative")
     | } else if (a % 2 == 0) {
     |   println("even")
     | } else {
     |   println("odd")
     | }
negative
</code></pre>

<p>If the condition is <em>false</em>, we have an additional check at <code class="language-scala">if else</code>, and only if this second condition is also <em>false</em>, we switch to the else-part. You can add as many <code class="language-scala">if else</code> sections as you want. </p>

<h5 id="one-line-vs-multi-line">One line vs multi-line</h5>

<p>You've probably noticed in the previous examples that we define <code class="language-scala">if-else</code> constructions a little bit differently: one is one-line and without brackets, while the other has multiple lines. What option should you choose? The answer is simple: readability is the main point.</p>

<pre><code class="language-scala">if (a == -5) -1 else 1
  
if (a &gt; 0) 
  println("The value of a is positive")
else if (a &lt; 0) 
  println("The value of a is negative")
else
  println("The value of a is 0")

if (a &lt; 0) {
  println("The value of a is negative")
  if (a % 2 == 0)
    println("The value of a is even")
}</code></pre>

<p>If you have short expressions in <em>then</em> and <em>else</em> parts, it's possible to place them all in one line. More complicated parts should be placed on multiple lines. If you have long multiline computations inside <code class="language-scala">if-else</code> , use brackets.</p>

<h5 id="branching-in-functions">Branching in functions</h5>

<p>You can get the full potential of branching by defining it in functions. Note that <code class="language-scala">if-else</code> is an expression computed in place of definition. To use the expression several times, just define it as a function:</p>

<pre><code class="language-scala">scala&gt; def isEven(x: Int) = if (x % 2 == 0) true else false
isEven: (x: Int)Boolean
scala&gt; isEven(10)
res3: Boolean = true
scala&gt; isEven(13)
res4: Boolean = false
</code></pre>

<p>We can use conditional computation and call the function itself inside:</p>

<pre><code class="language-scala">def count3(x: Int): Int =
  if (x == 0)
    0
  else if (x % 3 == 0)
    count3(x - 1) + 1
  else
    count3(x - 1)</code></pre>

<p>Here, we introduced the function <code class="language-scala">count3</code> to count numbers $1...x$ that are a fraction of 3.</p>

<h5 id="conclusion">Conclusion</h5>

<p>Situations when we need to make a choice happen every day. That's why the ability to do things conditionally is one of the cornerstones of programming. In Scala, you can use <code class="language-scala">if-else</code> expressions to describe the logic with two branches. If you have more than two, feel free to use <code class="language-scala">if-else-if</code> systax. With these instruments, you can define the expression or function in different ways, but remember to take care of the readability of your programs.</p>
